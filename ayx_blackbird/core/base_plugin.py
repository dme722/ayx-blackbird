"""Base plugin definition."""
import logging
import os
import sys
from abc import ABC, abstractmethod
from typing import List, NoReturn, Optional

import AlteryxPythonSDK as Sdk


from .connection_callback_strategy import (
    ConnectionCallbackStrategy,
    UpdateOnlyConnectionCallbackStrategy,
    WorkflowRunConnectionCallbackStrategy,
)
from .connection_interface import ConnectionInterface
from .events import ConnectionEvents, PluginEvents
from ..anchors import InputAnchor, OutputAnchor
from ..config import ToolConfiguration, WorkflowConfiguration
from ..mixins import AnchorUtilsMixin, ObservableMixin
from ..proxies import EngineProxy
from ..records import ParsedRecordContainer
from ..utilities.exceptions import WorkflowRuntimeError


class BasePlugin(ABC, AnchorUtilsMixin, ObservableMixin):
    """Base plugin to inherit from."""

    __slots__ = [
        "tool_id",
        "engine",
        "tool_config",
        "input_anchors",
        "output_anchors",
        "workflow_config",
        "failure_occurred",
        "initialized",
    ]

    def __init__(
        self,
        tool_id: int,
        alteryx_engine: Sdk.AlteryxEngine,
        output_anchor_mgr: Sdk.OutputAnchorManager,
    ):
        """Construct a plugin."""
        AnchorUtilsMixin.__init__(self)
        ObservableMixin.__init__(self)

        self.tool_id = tool_id
        self.engine = EngineProxy(alteryx_engine, tool_id)

        self.tool_config = ToolConfiguration(self.tool_name, output_anchor_mgr)

        self.failure_occurred = False

        self.configure_logger()

        # These properties get assigned in pi_init
        self.input_anchors: List[InputAnchor] = []
        self.output_anchors: List[OutputAnchor] = []
        self.workflow_config = WorkflowConfiguration("<Configuration/>")
        self.initialized = False

    def pi_init(self, workflow_config_xml_string: str) -> None:
        """Plugin initialization from the engine."""
        self.input_anchors = self.tool_config.build_input_anchors()
        self.output_anchors = self.tool_config.build_output_anchors()
        self.workflow_config = WorkflowConfiguration(workflow_config_xml_string)
        self.notify_topic(PluginEvents.PLUGIN_INITIALIZED)

    def pi_add_incoming_connection(
        self, anchor_name: str, connection_name: str
    ) -> ConnectionInterface:
        """Add incoming connection to the tool from the engine."""
        anchor = [a for a in self.input_anchors if a.name == anchor_name][0]

        connection = ConnectionInterface(self, connection_name, anchor)
        anchor.connections.append(connection)
        self._subscribe_to_connection(connection)
        return connection

    def _subscribe_to_connection(self, connection: ConnectionInterface) -> None:
        """Subscribe to events of interest generated by a connection."""
        connection.subscribe(
            ConnectionEvents.CONNECTION_INITIALIZED,
            self.callback_strategy.connection_initialized_callback,
        )
        connection.subscribe(
            ConnectionEvents.RECORD_RECEIVED,
            self.callback_strategy.record_received_callback,
        )
        connection.subscribe(
            ConnectionEvents.CONNECTION_CLOSED,
            self.callback_strategy.connection_closed_callback,
        )
        connection.subscribe(
            ConnectionEvents.PROGRESS_UPDATE,
            self.callback_strategy.update_progress_callback,
        )

    def pi_add_outgoing_connection(self, anchor_name: str) -> bool:
        """Register an outgoing connection from this tool."""
        anchor = [a for a in self.output_anchors if a.name == anchor_name][0]
        anchor.num_connections += 1
        return True

    def pi_push_all_records(self, n_record_limit: int) -> bool:
        """Push all records when no inputs are connected."""
        try:
            if len(self.required_input_anchors) == 0:
                self.initialize_plugin()
                self.initialized = True
                if not self.engine.update_only_mode:
                    self.on_complete()
                self.close_output_anchors()
                return True

            self.raise_missing_inputs()
        except Exception as e:
            self.handle_plugin_error(e)

        return False

    def raise_missing_inputs(self) -> NoReturn:
        """Send a missing incoming inputs error to Designer."""
        raise WorkflowRuntimeError(self.engine.xmsg("Missing Incoming Connection(s)."))

    def pi_close(self, b_has_errors: bool) -> None:
        """pi_close is useless. Never use it."""
        pass

    def configure_logger(self) -> None:
        """Configure the logger."""
        handler = logging.FileHandler(self.log_filepath)
        formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
        self.logger.setLevel(logging.DEBUG)

    def handle_plugin_error(self, e: Exception) -> None:
        """Log a plugin error to the log and a generic error to Designer."""
        logger = self.logger

        if isinstance(e, WorkflowRuntimeError):
            logger.error(str(e))
            self.engine.error(str(e))
        else:
            logger.exception(e)
            self.engine.error(
                self.engine.xmsg(
                    "Unexpected error occurred in plugin, "
                    f"please see log file: {self.log_filepath}"
                )
            )
        self.failure_occurred = True
        self.notify_topic(PluginEvents.PLUGIN_FAILURE, exception=e)

    @property
    def log_filepath(self) -> str:
        """Get the log filename."""
        if sys.platform == "win32":
            log_directory = os.path.join(os.environ["LOCALAPPDATA"], "Alteryx", "Log")
        else:
            log_directory = os.path.join("/var", "tmp")

        return os.path.join(log_directory, f"{self.tool_name}{self.tool_id}.log")

    @property
    def logger(self) -> logging.Logger:
        """Get logger."""
        return logging.getLogger(f"{self.tool_name}{self.tool_id}")

    @property
    def callback_strategy(self) -> ConnectionCallbackStrategy:
        """Generate the callback strategy for the tool."""
        return (
            UpdateOnlyConnectionCallbackStrategy(self)
            if self.engine.update_only_mode
            else WorkflowRunConnectionCallbackStrategy(self)
        )

    """All properties below this point can/should be overridden for custom tools."""

    @property
    @abstractmethod
    def tool_name(self) -> str:
        """Get the tool name."""
        pass

    @property
    @abstractmethod
    def record_batch_size(self) -> Optional[int]:
        """Get the record batch size."""
        pass

    def initialize_plugin(self) -> None:
        """Initialize plugin."""
        pass

    def initialize_connection(self, connection: ConnectionInterface) -> None:
        """Initialize a connection."""
        if connection.record_info is None:
            raise RuntimeError("Record info must be present before setting containers.")

        connection.add_record_container(ParsedRecordContainer(connection.record_info))

    def on_incoming_records(self, connection: ConnectionInterface) -> None:
        """Process records in batches."""
        pass

    def on_complete(self) -> None:
        """Close plugin code after all records have finished streaming."""
        pass
